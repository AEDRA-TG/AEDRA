using System.Collections.Generic;
using System.Collections;
using System;
using Utils.Enums;
using Model.Common;
using SideCar.Converters;
using SideCar.DTOs;
using UnityEngine;
using Newtonsoft.Json;
using Repository;

namespace Model.GraphModel
{
    /// <summary>
    /// Class to manage operations and data realted to a Graph
    /// </summary>
    public class Graph : DataStructure
    {
        /// <summary>
        /// Autogenerated Node Id
        /// </summary>
        [JsonProperty]
        public static int NodesId{get; set;}
        /// <summary>
        /// Autogenerated Edge id
        /// </summary>
        /// <value></value>
        [JsonProperty]
        public static int EdgesId{get; set;}

        /// <summary>
        /// List to store nodes of the graph
        /// </summary>
        public List<GraphNode> Nodes {get; set;}

        /// <summary>
        /// Adjacent matrix of the graph
        /// </summary>
        public Dictionary<int, Dictionary<int, object>> AdjacentMtx { get; set; }
        /// <summary>
        /// Class to convert between NodeDTO and GraphNode
        /// </summary>
        private GraphNodeConverter _nodeConverter;

        public Graph(){
            NodesId = 0;
            EdgesId = 0;
            Nodes = new List<GraphNode>();
            AdjacentMtx = new Dictionary<int, Dictionary<int, object>>();
            _nodeConverter = new GraphNodeConverter();
        }

        /// <summary>
        /// Method to add a node on the graph
        /// </summary>
        /// <param name="element"> Node that will be added to the graph </param>
        public override void AddElement(ElementDTO element)
        {
            GraphNode node = _nodeConverter.ToEntity((GraphNodeDTO)element);
            node.Id = NodesId++;
            Nodes.Add(node);
            AdjacentMtx.Add(node.Id, new Dictionary<int, object>());
            //return DTO updated
            element = _nodeConverter.ToDto(node);
            element.Operation = AnimationEnum.CreateAnimation;
            base.Notify(element);
        }

        /// <summary>
        /// Method to remove a node of the graph
        /// </summary>
        /// <param name="element"> Node that will be removed</param>
        public override void DeleteElement(ElementDTO element)
        {
            GraphNode nodeToDelete = _nodeConverter.ToEntity((GraphNodeDTO)element);
            this.Nodes.Remove(nodeToDelete);
            element.Operation = AnimationEnum.DeleteAnimation;
            base.Notify(element);
        }

        /// <summary>
        /// Method to do a traversal on the graph
        /// </summary>
        /// <param name="traversalName"> Name of the traversal to execute</param>
        public override void DoTraversal(string traversalName)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Method to connect two nodes bidirectionally
        /// </summary>
        /// <param name="element"></param>
        public override void ConnectElements(ElementDTO graphEdgeDTO)
        {
            GraphEdgeDTO edgeDTO = (GraphEdgeDTO) graphEdgeDTO;
            edgeDTO.Id = EdgesId++;
            AdjacentMtx[edgeDTO.Id].Add(edgeDTO.IdEndNode, edgeDTO.Value);
            AdjacentMtx[edgeDTO.IdEndNode].Add(edgeDTO.Id, edgeDTO.Value);
            edgeDTO.Operation = AnimationEnum.CreateAnimation;
            base.Notify(edgeDTO);
        }
        /// <summary>
        /// Method to obtain list of neighbors of a given node
        /// </summary>
        /// <param name="nodeId">Id of node to search</param>
        /// <returns>List of ids representing the neighbors of the node</returns>
        public List<int> GetNeighbors(int nodeId){
            List<int> neighbors = new List<int>();
            foreach (int neighbor in AdjacentMtx[nodeId].Keys)
            {
                neighbors.Add(neighbor);
            }
            return neighbors;
        }
    }
}