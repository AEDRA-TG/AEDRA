using System.Collections.Generic;
using System;
using Utils.Enums;
using Model.Common;
using SideCar.Converters;
using SideCar.DTOs;
using Newtonsoft.Json;
using UnityEngine;

namespace Model.GraphModel
{
    /// <summary>
    /// Class to manage operations and data realted to a Graph
    /// </summary>
    public class Graph : DataStructure
    {
        /// <summary>
        /// Autogenerated Node Id
        /// </summary>
        [JsonProperty]
        public static int NodesId{get; set;}
        /// <summary>
        /// Autogenerated Edge id
        /// </summary>
        /// <value></value>
        [JsonProperty]
        public static int EdgesId{get; set;}

        /// <summary>
        /// List to store nodes of the graph
        /// </summary>
        public List<GraphNode> Nodes {get; set;}

        /// <summary>
        /// Adjacent matrix of the graph
        /// </summary>
        public Dictionary<int, Dictionary<int, object>> AdjacentMtx { get; set; }
        /// <summary>
        /// Class to convert between NodeDTO and GraphNode
        /// </summary>
        private GraphNodeConverter _nodeConverter;

        public Graph(){
            NodesId = 0;
            EdgesId = 0;
            Nodes = new List<GraphNode>();
            AdjacentMtx = new Dictionary<int, Dictionary<int, object>>();
            _nodeConverter = new GraphNodeConverter();
        }

        /// <summary>
        /// Method to add a node on the graph
        /// </summary>
        /// <param name="element"> Node that will be added to the graph </param>
        public override void AddElement(ElementDTO element)
        {
            GraphNode node = _nodeConverter.ToEntity((GraphNodeDTO)element);
            node.Id = NodesId++;
            Nodes.Add(node);
            AdjacentMtx.Add(node.Id, new Dictionary<int, object>());
            //return DTO updated
            element = _nodeConverter.ToDto(node);
            element.Operation = AnimationEnum.CreateAnimation;
            base.Notify(element);
        }

        /// <summary>
        /// Method to remove a node of the graph
        /// </summary>
        /// <param name="element"> Node that will be removed</param>
        public override void DeleteElement(ElementDTO element)
        {
            GraphNode nodeToDelete = _nodeConverter.ToEntity((GraphNodeDTO)element);
            // Deleting all edges
            DeleteEdges(nodeToDelete.Id);
            this.Nodes.Remove(nodeToDelete);
            element.Operation = AnimationEnum.DeleteAnimation;
            base.Notify(element);
        }

        /// <summary>
        /// Method to do a traversal on the graph
        /// </summary>
        /// <param name="traversalName"> Name of the traversal to execute</param>
        public override void DoTraversal(string traversalName)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Method to connect two nodes bidirectionally
        /// </summary>
        /// <param name="element"></param>
        public override void ConnectElements(ElementDTO graphEdgeDTO)
        {
            GraphEdgeDTO edgeDTO = (GraphEdgeDTO) graphEdgeDTO;
            edgeDTO.Id = EdgesId++;
            // TODO: validar aristas
            bool edgeStartToEnd = AdjacentMtx[edgeDTO.IdStartNode].ContainsKey(edgeDTO.IdEndNode);
            bool edgeEndToStart = AdjacentMtx[edgeDTO.IdEndNode].ContainsKey(edgeDTO.IdStartNode);
            if(!edgeStartToEnd && !edgeEndToStart){
                AdjacentMtx[edgeDTO.IdStartNode].Add(edgeDTO.IdEndNode, edgeDTO.Value);
                AdjacentMtx[edgeDTO.IdEndNode].Add(edgeDTO.IdStartNode, edgeDTO.Value);
                edgeDTO.Operation = AnimationEnum.CreateAnimation;
                base.Notify(edgeDTO);
            }
            else{
                Debug.Log("Ya existe la arista");
            }
        }
        /// <summary>
        /// Method to obtain list of neighbors of a given node
        /// </summary>
        /// <param name="nodeId">Id of node to search</param>
        /// <returns>List of ids representing the neighbors of the node</returns>
        public List<int> GetNeighbors(int nodeId){
            List<int> neighbors = new List<int>();
            foreach (int neighbor in AdjacentMtx[nodeId].Keys)
            {
                neighbors.Add(neighbor);
            }
            return neighbors;
        }

        /// <summary>
        /// Method to obtain list of neighbors of a given node
        /// </summary>
        /// <param name="nodeId">Id of node to search</param>
        /// <returns>List of ids representing the neighbors of the node</returns>
        public void DeleteEdges(int nodeId){
            if(AdjacentMtx.ContainsKey(nodeId))
            {
                foreach (int key in AdjacentMtx.Keys)
                {
                    bool existsStartToEnd = AdjacentMtx[key].Remove(nodeId);
                    bool existsEndToStart = AdjacentMtx[nodeId].Remove(key);
                    if(existsStartToEnd || existsEndToStart){
                       GraphEdgeDTO edgeDTO = new GraphEdgeDTO(0,0,key,nodeId);
                       edgeDTO.Operation = AnimationEnum.DeleteAnimation;
                       base.Notify(edgeDTO);
                    }
                }
            }
            AdjacentMtx.Remove(nodeId);
        }

    }
}