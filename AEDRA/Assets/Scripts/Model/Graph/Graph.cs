using System.Collections.Generic;
using System;
using Utils.Enums;
using Model.Common;
using SideCar.Converters;
using SideCar.DTOs;
using Newtonsoft.Json;
using Repository;
using Utils;
using UnityEngine;
using System.Linq;
using System.Collections;

namespace Model.GraphModel
{
    /// <summary>
    /// Class to manage operations and data realted to a Graph
    /// </summary>
    public class Graph : DataStructure
    {
        /// <summary>
        /// Autogenerated Node Id
        /// </summary>
        [JsonProperty]
        public static int NodesId{get; set;}
        /// <summary>
        /// Autogenerated Edge id
        /// </summary>
        /// <value></value>
        [JsonProperty]
        public static int EdgesId{get; set;}

        /// <summary>
        /// List to store nodes of the graph
        /// </summary>
        public List<GraphNode> Nodes {get; set;}

        /// <summary>
        /// Adjacent matrix of the graph
        /// </summary>
        public Dictionary<int, Dictionary<int, object>> AdjacentMtx { get; set; }
        /// <summary>
        /// Class to convert between NodeDTO and GraphNode
        /// </summary>
        private GraphNodeConverter _nodeConverter;

        private Dictionary<TraversalEnum, Action<ElementDTO>> _traversals;

        public Graph(){
            NodesId = 0;
            EdgesId = 0;
            Nodes = new List<GraphNode>();
            AdjacentMtx = new Dictionary<int, Dictionary<int, object>>();
            _nodeConverter = new GraphNodeConverter();
            _traversals = new Dictionary<TraversalEnum, Action<ElementDTO>>() {
                {TraversalEnum.GraphBFS, BFSTraversal},
            };
        }

        /// <summary>
        /// Method to add a node on the graph
        /// </summary>
        /// <param name="element"> Node that will be added to the graph </param>
        public override void AddElement(ElementDTO element)
        {
            GraphNode node = _nodeConverter.ToEntity((GraphNodeDTO)element);
            node.Id = NodesId++;
            Nodes.Add(node);
            AdjacentMtx.Add(node.Id, new Dictionary<int, object>());
            //return DTO updated
            node.Coordinates = Utilities.GenerateRandomPoint();
            element = _nodeConverter.ToDto(node);
            element.Operation = AnimationEnum.CreateAnimation;
            base.Notify(element);
        }

        /// <summary>
        /// Method to remove a node of the graph
        /// </summary>
        /// <param name="element"> Node that will be removed</param>
        public override void DeleteElement(ElementDTO element)
        {
            DeleteEdges(element.Id);
            this.Nodes.Remove( Nodes.SingleOrDefault( n => n.Id == element.Id ) ); //TODO: Salvajada de Daniel
            element.Operation = AnimationEnum.DeleteAnimation;
            base.Notify(element);
        }

        /// <summary>
        /// Method to do a traversal on the graph
        /// </summary>
        /// <param name="traversalName"> Name of the traversal to execute</param>
        public override void DoTraversal(TraversalEnum traversalName, ElementDTO startNode)
        {
            this._traversals[traversalName](startNode);
        }

        private void BFSTraversal(ElementDTO startNode){
            Dictionary<GraphNode, bool> visitedMap = InitializeVisiteMap();
            Queue<GraphNode> q = new Queue<GraphNode>();
            q.Enqueue(_nodeConverter.ToEntity((GraphNodeDTO)startNode));
            while(q.Count > 0){
                GraphNode actualNode = q.Dequeue();
                visitedMap[actualNode] = true;
                GraphNodeDTO visitedDTO = _nodeConverter.ToDto(actualNode);
                visitedDTO.Operation = AnimationEnum.PaintAnimation;
                base.Notify(visitedDTO);
                foreach (int key in AdjacentMtx[actualNode.Id].Keys)
                {
                    GraphNode neighboorNode = GetNodeById(key);
                    if(!visitedMap[neighboorNode]){
                        GraphEdgeDTO edgeDTO = new GraphEdgeDTO(0, AdjacentMtx[actualNode.Id][key], actualNode.Id, key)
                        {
                            Operation = AnimationEnum.PaintAnimation
                        };
                        //base.Notify(edgeDTO);
                        q.Enqueue(neighboorNode);
                    }
                }
            }
        }

        private GraphNode GetNodeById(int id){
            foreach(GraphNode node in this.Nodes){
                if(node.Id == id){
                    return node;
                }
            }
            return null;
        }

        /// <summary>
        /// Method to initialize the visited map for traversals
        /// </summary>
        /// <returns></returns>
        private Dictionary<GraphNode, bool> InitializeVisiteMap(){
            Dictionary<GraphNode, bool> visitedMap = new Dictionary<GraphNode, bool>();
            foreach (GraphNode node in Nodes)
            {
                visitedMap.Add(node, false);
            }
            return visitedMap;
        }

        /// <summary>
        /// Method to connect two nodes bidirectionally
        /// </summary>
        /// <param name="element"></param>
        public override void ConnectElements(ElementDTO graphEdgeDTO)
        {
            GraphEdgeDTO edgeDTO = (GraphEdgeDTO) graphEdgeDTO;
            edgeDTO.Id = EdgesId++;
            // TODO: validar aristas
            bool edgeStartToEnd = AdjacentMtx[edgeDTO.IdStartNode].ContainsKey(edgeDTO.IdEndNode);
            bool edgeEndToStart = AdjacentMtx[edgeDTO.IdEndNode].ContainsKey(edgeDTO.IdStartNode);
            if(!edgeStartToEnd && !edgeEndToStart){
                AdjacentMtx[edgeDTO.IdStartNode].Add(edgeDTO.IdEndNode, edgeDTO.Value);
                AdjacentMtx[edgeDTO.IdEndNode].Add(edgeDTO.IdStartNode, edgeDTO.Value);
                edgeDTO.Operation = AnimationEnum.CreateAnimation;
                base.Notify(edgeDTO);
            }
            else{
                Debug.Log("Ya existe la arista");
            }
        }
        /// <summary>
        /// Method to obtain list of neighbors of a given node
        /// </summary>
        /// <param name="nodeId">Id of node to search</param>
        /// <returns>List of ids representing the neighbors of the node</returns>
        public List<int> GetNeighbors(int nodeId){
            List<int> neighbors = new List<int>();
            foreach (int neighbor in AdjacentMtx[nodeId].Keys)
            {
                neighbors.Add(neighbor);
            }
            return neighbors;
        }

        //TODO: rename method or create graph from this 
        public override void CreateDataStructure()
        {
            Dictionary<int,bool> visited = new Dictionary<int, bool>();
            foreach (GraphNode node in this.Nodes)
            {
                GraphNodeDTO dto = _nodeConverter.ToDto(node);
                dto.Operation = AnimationEnum.CreateAnimation;
                visited.Add(node.Id,false);
                base.Notify(dto);
            }
            foreach (GraphNode node in this.Nodes)
            {
                visited[node.Id] = true;
                foreach (int key in this.AdjacentMtx[node.Id].Keys)
                {
                    if(!visited[key]){
                        GraphEdgeDTO edgeDTO = new GraphEdgeDTO(0, AdjacentMtx[node.Id][key], node.Id, key)
                        {
                            Operation = AnimationEnum.CreateAnimation
                        };
                        base.Notify(edgeDTO);
                    }
                }
            }
        }
        /// <summary>
        /// Method to obtain list of neighbors of a given node
        /// </summary>
        /// <param name="nodeId">Id of node to search</param>
        /// <returns>List of ids representing the neighbors of the node</returns>
        public void DeleteEdges(int nodeId){
            if(AdjacentMtx.ContainsKey(nodeId))
            {
                foreach (int key in AdjacentMtx.Keys)
                {
                    bool existsStartToEnd = AdjacentMtx[key].Remove(nodeId);
                    bool existsEndToStart = AdjacentMtx[nodeId].Remove(key);
                    if(existsStartToEnd || existsEndToStart){
                        GraphEdgeDTO edgeDTO = new GraphEdgeDTO(0, 0, key, nodeId)
                        {
                            Operation = AnimationEnum.DeleteAnimation
                        };
                        NotifyNode(nodeId,AnimationEnum.UpdateAnimation);
                       NotifyNode(key,AnimationEnum.UpdateAnimation);
                       base.Notify(edgeDTO);
                    }
                }
            }
            AdjacentMtx.Remove(nodeId);
        }

        private void NotifyNode(int id, AnimationEnum operation){
            GraphNode node = this.Nodes.Single( n => n.Id == id ); //TODO: Salvajada de Daniel
            GraphNodeDTO dto = _nodeConverter.ToDto(node);
            dto.Operation = operation;
            base.Notify(dto);
        }
    }
}